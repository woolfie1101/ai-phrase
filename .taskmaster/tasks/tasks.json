{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 초기 설정 및 기본 구조 구축",
        "description": "Next.js 프로젝트를 생성하고 Supabase, Tailwind CSS, Shadcn/ui 등 필요한 라이브러리를 설정합니다.",
        "details": "1. Next.js 프로젝트 생성: `npx create-next-app@latest anki-web-app --typescript`\n2. Tailwind CSS 설정: `npm install -D tailwindcss postcss autoprefixer` 및 설정 파일 생성\n3. Shadcn/ui 설치: `npx shadcn-ui@latest init`\n4. Lucide-react 아이콘 설치: `npm install lucide-react`\n5. Supabase 클라이언트 설정: `npm install @supabase/supabase-js`\n6. 기본 폴더 구조 설정 (components, lib, hooks, types 등)\n7. 환경 변수 설정 (.env.local 파일 생성)\n8. 기본 레이아웃 컴포넌트 생성\n9. 타입스크립트 타입 정의 파일 생성",
        "testStrategy": "1. 프로젝트가 오류 없이 빌드되는지 확인\n2. 개발 서버가 정상적으로 실행되는지 확인\n3. 모든 라이브러리가 올바르게 설치되었는지 확인\n4. 환경 변수가 올바르게 로드되는지 확인",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Next.js 프로젝트 생성 및 기본 설정",
            "description": "Next.js 프로젝트를 생성하고 TypeScript, ESLint 등 기본 설정을 구성합니다.",
            "dependencies": [],
            "details": "1. create-next-app을 사용하여 프로젝트 생성: `npx create-next-app@latest my-project --typescript`\n2. ESLint 설정 확인 및 필요시 추가 규칙 구성\n3. tsconfig.json 설정 검토 및 필요한 옵션 추가\n4. 프로젝트 실행 테스트: `npm run dev`\n5. .gitignore 파일 확인 및 필요한 항목 추가",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Tailwind CSS 및 UI 라이브러리 설치",
            "description": "Tailwind CSS와 Shadcn/ui 라이브러리를 설치하고 구성합니다.",
            "dependencies": [],
            "details": "1. Tailwind CSS 설치: `npm install -D tailwindcss postcss autoprefixer`\n2. Tailwind 초기화: `npx tailwindcss init -p`\n3. tailwind.config.js 파일 구성 (content, theme 등 설정)\n4. globals.css에 Tailwind 지시어 추가\n5. Shadcn/ui 설치: `npx shadcn-ui@latest init`\n6. 필요한 Shadcn 컴포넌트 추가: `npx shadcn-ui@latest add button card input`\n7. 테마 설정 및 커스터마이징",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Supabase 설정 및 클라이언트 구성",
            "description": "Supabase 프로젝트를 생성하고 클라이언트 라이브러리를 설치합니다.",
            "dependencies": [],
            "details": "1. Supabase 계정 생성 및 새 프로젝트 설정\n2. Supabase 클라이언트 라이브러리 설치: `npm install @supabase/supabase-js`\n3. 환경 변수 설정을 위한 .env.local 파일 생성\n4. Supabase URL 및 API 키 환경 변수 추가\n5. lib/supabase.ts 파일 생성하여 Supabase 클라이언트 초기화 코드 작성\n6. 기본 인증 설정 구성 (이메일/비밀번호, OAuth 등)\n7. RLS(Row Level Security) 기본 정책 설정",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "프로젝트 폴더 구조 설계",
            "description": "효율적인 개발을 위한 프로젝트 폴더 구조를 설계하고 구성합니다.",
            "dependencies": [],
            "details": "1. app/ 디렉토리 내 라우트 구조 설계 (홈, 인증, 대시보드 등)\n2. components/ 폴더 생성 및 하위 구조 설계 (ui/, layout/, auth/ 등)\n3. lib/ 폴더 생성 (유틸리티 함수, 헬퍼 등)\n4. hooks/ 폴더 생성 (커스텀 훅)\n5. types/ 폴더 생성 (타입 정의)\n6. public/ 폴더 내 assets 구조화\n7. context/ 폴더 생성 (상태 관리)\n8. services/ 폴더 생성 (API 호출 관련 로직)",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "타입스크립트 타입 정의 및 인터페이스 설계",
            "description": "프로젝트에서 사용할 주요 타입과 인터페이스를 정의합니다.",
            "dependencies": [],
            "details": "1. types/index.ts 파일 생성\n2. 사용자 관련 타입 정의 (User, UserProfile 등)\n3. 데이터 모델 타입 정의 (Folder, File, Flashcard 등)\n4. API 응답 타입 정의\n5. 컴포넌트 Props 타입 정의\n6. 유틸리티 타입 정의 (Partial, Pick 등 활용)\n7. Supabase 데이터베이스 타입 정의",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "기본 레이아웃 및 공통 컴포넌트 생성",
            "description": "애플리케이션의 기본 레이아웃과 자주 사용되는 공통 컴포넌트를 구현합니다.",
            "dependencies": [],
            "details": "1. app/layout.tsx 파일 구성 (메타데이터, 전역 스타일 등)\n2. 헤더 컴포넌트 구현 (네비게이션, 로고, 사용자 메뉴 등)\n3. 푸터 컴포넌트 구현\n4. 사이드바 컴포넌트 구현\n5. 로딩 및 에러 상태 컴포넌트 구현\n6. 모달 및 다이얼로그 컴포넌트 구현\n7. 토스트/알림 컴포넌트 구현",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "환경 변수 설정 및 구성 파일 작성",
            "description": "프로젝트에 필요한 환경 변수를 설정하고 구성 파일을 작성합니다.",
            "dependencies": [],
            "details": "1. .env.example 파일 생성 (필요한 환경 변수 목록 및 예시)\n2. .env.local 파일 구성 (개발 환경용)\n3. .env.production 파일 구성 (배포 환경용)\n4. config.ts 파일 생성 (환경 변수 타입 안전하게 로드)\n5. next.config.js 파일 구성 (환경 변수, 이미지 최적화 등)\n6. 환경별 설정 분리 (개발, 테스트, 프로덕션)\n7. 환경 변수 유효성 검사 로직 구현",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Supabase 데이터베이스 스키마 설계 및 구현",
        "description": "사용자, 폴더, 파일, 플래시카드 등의 데이터 모델을 설계하고 Supabase에 테이블을 생성합니다.",
        "details": "다음 테이블을 생성합니다:\n\n1. `users`: 사용자 정보 (id, email, created_at 등)\n2. `folders`: 폴더 정보 (id, name, parent_folder_id, user_id, created_at, updated_at)\n3. `files`: 파일 정보 (id, name, folder_id, user_id, learning_method, created_at, updated_at)\n4. `flashcards`: 플래시카드 정보 (id, file_id, front_content, back_content, example_memo, created_at, updated_at)\n5. `card_progress`: 카드 학습 진행 상태 (id, user_id, card_id, status(new/learning/review), ease_factor, interval, next_review_date, review_count)\n6. `schedules`: 학습 스케줄 (id, user_id, target_id, target_type(folder/file), days_of_week, created_at, updated_at)\n7. `learning_streaks`: 연속 학습 기록 (id, user_id, streak_count, last_study_date)\n\n각 테이블에 적절한 외래 키 제약 조건과 인덱스를 설정합니다. RLS(Row Level Security) 정책을 구성하여 사용자별 데이터 접근을 제한합니다.",
        "testStrategy": "1. 각 테이블이 올바른 스키마로 생성되었는지 확인\n2. 외래 키 제약 조건이 올바르게 작동하는지 테스트\n3. RLS 정책이 올바르게 적용되는지 확인 (다른 사용자의 데이터에 접근할 수 없어야 함)\n4. 기본적인 CRUD 작업이 모든 테이블에서 정상적으로 작동하는지 확인",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "각 테이블별 스키마 설계",
            "description": "users, folders, files, flashcards, card_progress, schedules, streaks 등 각 테이블의 컬럼, 타입, 제약조건을 설계합니다.",
            "dependencies": [],
            "details": "ERD 작성, 각 테이블별 필수 컬럼 및 관계 정의, NOT NULL/UNIQUE 등 제약조건 설계",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "테이블 생성 쿼리 작성 및 실행",
            "description": "설계된 스키마를 기반으로 Supabase에서 각 테이블을 실제로 생성합니다.",
            "dependencies": [
              "2.1"
            ],
            "details": "SQL CREATE TABLE 쿼리 작성 및 Supabase SQL Editor에서 실행",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "외래키 및 인덱스 설정",
            "description": "테이블 간 관계를 위한 외래키와 성능 향상을 위한 인덱스를 설정합니다.",
            "dependencies": [
              "2.2"
            ],
            "details": "FOREIGN KEY, ON DELETE/UPDATE, 주요 컬럼 인덱스 생성",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "각 테이블별 샘플 데이터 삽입",
            "description": "테이블 구조와 제약조건이 정상적으로 동작하는지 확인하기 위해 샘플 데이터를 삽입합니다.",
            "dependencies": [
              "2.3"
            ],
            "details": "INSERT INTO 쿼리로 users, folders, files 등 각 테이블에 테스트 데이터 입력",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "RLS 정책 설계 및 적용",
            "description": "사용자별 데이터 접근 제한을 위한 RLS(Row Level Security) 정책을 설계하고 적용합니다.",
            "dependencies": [
              "2.4"
            ],
            "details": "각 테이블에 enable_rls, 정책(Policy) 추가, user_id 기반 접근 제한",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "RLS 정책 테스트",
            "description": "다른 사용자의 데이터에 접근이 차단되는지 실제로 테스트합니다.",
            "dependencies": [
              "2.5"
            ],
            "details": "다른 user_id로 SELECT/UPDATE/DELETE 시도, 권한 오류 발생 확인",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "CRUD 쿼리 작성 및 실행",
            "description": "각 테이블에 대해 CREATE, READ, UPDATE, DELETE 쿼리를 작성하고 정상 동작 여부를 확인합니다.",
            "dependencies": [
              "2.6"
            ],
            "details": "INSERT, SELECT, UPDATE, DELETE 쿼리 실행 및 결과 검증",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "전체 스키마 및 정책 검증",
            "description": "테이블 구조, 외래키, 인덱스, RLS 정책, CRUD 동작 등 전체적으로 정상 동작하는지 최종 검증합니다.",
            "dependencies": [
              "2.7"
            ],
            "details": "종합 테스트 시나리오 수행, 문제점 발견 시 수정 및 재검증",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Supabase 인증 시스템 구현",
        "description": "Supabase Auth를 사용하여 사용자 로그인, 회원가입 및 인증 시스템을 구현합니다.",
        "details": "1. Supabase Auth 설정: 이메일/비밀번호 인증 활성화\n2. 회원가입 페이지 구현: `/auth/signup` 경로에 회원가입 폼 생성\n3. 로그인 페이지 구현: `/auth/login` 경로에 로그인 폼 생성\n4. 비밀번호 재설정 기능 구현\n5. 인증 상태 관리를 위한 컨텍스트 생성: `AuthContext.tsx`\n6. 인증이 필요한 페이지에 대한 보호 미들웨어 구현: `middleware.ts`\n7. 로그아웃 기능 구현\n8. 사용자 프로필 페이지 구현 (선택적)\n\n```typescript\n// auth-context.tsx 예시\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport { supabase } from '@/lib/supabase';\nimport { User } from '@supabase/supabase-js';\n\nconst AuthContext = createContext<{ user: User | null; loading: boolean }>({ user: null, loading: true });\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {\n      setUser(session?.user ?? null);\n      setLoading(false);\n    });\n\n    return () => subscription.unsubscribe();\n  }, []);\n\n  return <AuthContext.Provider value={{ user, loading }}>{children}</AuthContext.Provider>;\n};\n\nexport const useAuth = () => useContext(AuthContext);\n```",
        "testStrategy": "1. 회원가입 프로세스가 정상적으로 작동하는지 테스트\n2. 로그인 프로세스가 정상적으로 작동하는지 테스트\n3. 비밀번호 재설정 기능이 정상적으로 작동하는지 테스트\n4. 인증되지 않은 사용자가 보호된 페이지에 접근할 수 없는지 확인\n5. 로그아웃 기능이 정상적으로 작동하는지 테스트\n6. 인증 상태가 페이지 새로고침 후에도 유지되는지 확인",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Supabase Auth 설정 및 구성",
            "description": "Supabase 프로젝트에서 이메일/비밀번호 인증을 활성화하고 필요한 설정을 구성합니다.",
            "dependencies": [],
            "details": "1. Supabase 대시보드에서 Authentication 설정 활성화\n2. 이메일/비밀번호 인증 방식 활성화\n3. 이메일 템플릿 커스터마이징(회원가입 확인, 비밀번호 재설정)\n4. 리디렉션 URL 설정\n5. 프로젝트에 Supabase Auth 클라이언트 연결 설정",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "회원가입 페이지 구현",
            "description": "사용자가 새 계정을 생성할 수 있는 회원가입 페이지를 구현합니다.",
            "dependencies": [],
            "details": "1. `/auth/signup` 경로에 회원가입 페이지 생성\n2. 이메일, 비밀번호, 비밀번호 확인 입력 필드 구현\n3. 유효성 검사 로직 추가(이메일 형식, 비밀번호 강도, 일치 여부)\n4. 회원가입 제출 처리 및 오류 핸들링\n5. 회원가입 성공 시 로그인 페이지로 리디렉션",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "로그인 페이지 구현",
            "description": "기존 사용자가 계정에 로그인할 수 있는 로그인 페이지를 구현합니다.",
            "dependencies": [],
            "details": "1. `/auth/login` 경로에 로그인 페이지 생성\n2. 이메일, 비밀번호 입력 필드 구현\n3. 로그인 제출 처리 및 오류 핸들링\n4. '비밀번호 찾기' 링크 추가\n5. 로그인 성공 시 대시보드로 리디렉션\n6. 로그인 상태 유지 옵션 구현",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "비밀번호 재설정 기능 구현",
            "description": "사용자가 비밀번호를 잊어버렸을 때 재설정할 수 있는 기능을 구현합니다.",
            "dependencies": [],
            "details": "1. `/auth/forgot-password` 페이지 구현\n2. 이메일 입력 폼 및 제출 처리\n3. 비밀번호 재설정 이메일 발송 로직 구현\n4. `/auth/reset-password` 페이지 구현\n5. 새 비밀번호 입력 및 확인 폼 구현\n6. 비밀번호 재설정 완료 후 로그인 페이지로 리디렉션",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "인증 컨텍스트 및 상태 관리 구현",
            "description": "애플리케이션 전체에서 사용자 인증 상태를 관리할 수 있는 컨텍스트를 구현합니다.",
            "dependencies": [],
            "details": "1. `AuthContext.tsx` 파일 생성\n2. 사용자 인증 상태 관리 로직 구현\n3. 로그인, 로그아웃, 회원가입 함수 구현\n4. 사용자 세션 유지 및 새로고침 처리\n5. 인증 상태 변경 이벤트 리스너 설정\n6. 사용자 프로필 정보 가져오기 함수 구현",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "인증 보호 미들웨어 및 로그아웃 기능 구현",
            "description": "인증이 필요한 페이지를 보호하는 미들웨어와 로그아웃 기능을 구현합니다.",
            "dependencies": [],
            "details": "1. `middleware.ts` 파일 생성\n2. 보호된 경로에 대한 인증 확인 로직 구현\n3. 인증되지 않은 사용자 리디렉션 처리\n4. 로그아웃 기능 구현\n5. 로그아웃 후 세션 정리 및 리디렉션 처리\n6. 공개 경로와 보호된 경로 구분 설정",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "사용자 프로필 페이지 및 통합 테스트",
            "description": "사용자 프로필 페이지를 구현하고 모든 인증 기능에 대한 통합 테스트를 수행합니다.",
            "dependencies": [],
            "details": "1. `/profile` 페이지 구현\n2. 사용자 정보 표시 및 수정 기능 구현\n3. 회원가입 프로세스 테스트\n4. 로그인 프로세스 테스트\n5. 비밀번호 재설정 기능 테스트\n6. 인증 보호 미들웨어 테스트\n7. 로그아웃 기능 테스트\n8. 페이지 새로고침 후 인증 상태 유지 테스트",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "폴더 및 파일 관리 시스템 구현",
        "description": "사용자가 학습 자료를 체계적으로 정리할 수 있는 폴더 및 파일 관리 시스템을 구현합니다.",
        "details": "1. 폴더 및 파일 목록 표시 컴포넌트 구현\n2. 폴더 생성, 이름 변경, 삭제 기능 구현\n3. 파일 생성, 이름 변경, 삭제 기능 구현\n4. 계층적 폴더 구조 지원 (무한 중첩 가능)\n5. 드래그 앤 드롭으로 폴더/파일 이동 기능 구현 (react-dnd 라이브러리 활용)\n6. 폴더/파일 관련 API 엔드포인트 구현\n   - GET /api/folders - 사용자의 모든 폴더 목록 조회\n   - POST /api/folders - 새 폴더 생성\n   - PUT /api/folders/:id - 폴더 정보 업데이트\n   - DELETE /api/folders/:id - 폴더 삭제\n   - GET /api/folders/:id/files - 특정 폴더의 파일 목록 조회\n   - POST /api/files - 새 파일 생성\n   - PUT /api/files/:id - 파일 정보 업데이트\n   - DELETE /api/files/:id - 파일 삭제\n7. 파일 탐색기 스타일의 UI 구현 (Shadcn/ui의 Tree 컴포넌트 활용)\n\n```typescript\n// 폴더 생성 API 예시\nexport async function POST(req: Request) {\n  const { name, parentFolderId, userId } = await req.json();\n  const supabase = createServerClient();\n  \n  const { data, error } = await supabase\n    .from('folders')\n    .insert({\n      name,\n      parent_folder_id: parentFolderId || null,\n      user_id: userId\n    })\n    .select();\n  \n  if (error) return NextResponse.json({ error: error.message }, { status: 400 });\n  return NextResponse.json(data[0]);\n}\n```",
        "testStrategy": "1. 폴더 생성, 이름 변경, 삭제 기능이 정상적으로 작동하는지 테스트\n2. 파일 생성, 이름 변경, 삭제 기능이 정상적으로 작동하는지 테스트\n3. 계층적 폴더 구조가 올바르게 표시되는지 확인\n4. 드래그 앤 드롭으로 폴더/파일 이동이 정상적으로 작동하는지 테스트\n5. 다른 사용자의 폴더/파일에 접근할 수 없는지 확인\n6. 폴더 삭제 시 하위 폴더와 파일이 함께 삭제되는지 확인",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "폴더/파일 목록 컴포넌트 설계 및 구현",
            "description": "폴더와 파일의 계층 구조를 시각적으로 표시하는 목록 컴포넌트를 설계하고 구현합니다.",
            "dependencies": [],
            "details": "React 기반 트리 구조 UI 컴포넌트 구현, 폴더/파일 아이콘 및 이름 표시, 계층적 데이터 렌더링 지원\n<info added on 2025-08-10T11:49:24.657Z>\n폴더/파일 목록 컴포넌트 구현이 완료되었습니다. 주요 구현 내용은 다음과 같습니다:\n\n1. FolderTree 컴포넌트:\n   - 계층적 폴더 구조 시각화\n   - 드래그앤드롭 기능으로 폴더/파일 이동 지원\n   - 폴더별 색상 및 학습 스케줄 표시 기능\n\n2. FileManager 컴포넌트:\n   - 파일 목록 표시 및 CRUD 기능 구현\n   - 플래시카드 편집기와 연동 (BookOpen 아이콘으로 접근)\n   - 파일별 학습 모드 설정 (양방향/앞→뒤/뒤→앞)\n\n3. 백엔드 연동:\n   - 폴더 생성/수정/삭제 API 연동 완료\n   - 파일 생성/수정/삭제 기능 구현\n\n4. 사용자 경험 개선:\n   - 직관적인 드래그앤드롭 인터페이스\n   - 폴더 색상 및 스케줄 시각적 표시\n   - 플래시카드 편집기 원활한 통합\n</info added on 2025-08-10T11:49:24.657Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "폴더 생성, 이름 변경, 삭제 기능 구현",
            "description": "폴더의 생성, 이름 변경, 삭제 기능을 UI 및 상태 관리와 연동하여 구현합니다.",
            "dependencies": [
              "4.1"
            ],
            "details": "새 폴더 추가, 폴더 이름 인라인 수정, 폴더 삭제 시 하위 항목 처리, 상태 동기화",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "파일 생성, 이름 변경, 삭제 기능 구현",
            "description": "파일의 생성, 이름 변경, 삭제 기능을 UI 및 상태 관리와 연동하여 구현합니다.",
            "dependencies": [
              "4.1"
            ],
            "details": "새 파일 추가, 파일 이름 인라인 수정, 파일 삭제, 폴더 내 파일 관리",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "계층적 폴더 구조(무한 중첩) 지원",
            "description": "폴더가 폴더 내부에 무한히 중첩될 수 있도록 데이터 구조와 UI를 설계 및 구현합니다.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "parent_folder_id 기반 트리 구조, 재귀적 렌더링, 중첩 폴더 생성/이동 지원",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "드래그 앤 드롭 이동 기능 구현",
            "description": "폴더 및 파일을 드래그 앤 드롭으로 다른 폴더로 이동할 수 있는 기능을 구현합니다.",
            "dependencies": [
              "4.1",
              "4.4"
            ],
            "details": "react-dnd 등 라이브러리 활용, 드래그 시 시각적 피드백, 이동 후 상태 및 서버 동기화",
            "status": "deferred",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "폴더/파일 관련 API 엔드포인트 구현",
            "description": "폴더 및 파일의 CRUD, 이동 등 기능을 위한 RESTful API 엔드포인트를 구현합니다.",
            "dependencies": [
              "4.2",
              "4.3",
              "4.4",
              "4.5"
            ],
            "details": "GET/POST/PUT/DELETE 엔드포인트, 계층 구조 반영, 이동/삭제 시 하위 항목 처리",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "파일 탐색기 스타일 UI 완성",
            "description": "사용자 친화적인 파일 탐색기 스타일의 UI를 완성합니다.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4",
              "4.5"
            ],
            "details": "폴더/파일 트리, 컨텍스트 메뉴, 선택/다중 선택, 반응형 레이아웃, UX 개선",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "접근 권한 및 보안 테스트",
            "description": "폴더/파일 접근 권한, 삭제 시 하위 항목 처리 등 보안 및 권한 관련 테스트를 수행합니다.",
            "dependencies": [
              "4.6",
              "4.7"
            ],
            "details": "다른 사용자 데이터 접근 차단, 폴더 삭제 시 하위 항목 일괄 삭제, RLS 정책 검증",
            "status": "deferred",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Anki 학습 로직 구현",
        "description": "Anki의 간격 반복(Spaced Repetition) 알고리즘을 구현하여 플래시카드의 복습 간격을 동적으로 조정합니다.",
        "details": "1. SM-2 알고리즘 구현:\n   - 카드 상태 관리 (New, Learning, Review)\n   - 복습 간격 계산 로직 구현\n   - 사용자 응답에 따른 간격 조정 (Again, Hard, Good, Easy)\n2. 카드 큐 관리 시스템 구현:\n   - 오늘 학습해야 할 카드 선별 로직\n   - 카드 우선순위 설정 (New > Learning > Review)\n3. 카드 진행 상태 업데이트 함수 구현\n4. 카드 복습 일정 계산 함수 구현\n\n```typescript\n// SM-2 알고리즘 핵심 로직 예시\nfunction calculateNextInterval(card, response) {\n  const now = new Date();\n  let newInterval, newEaseFactor, newStatus;\n  \n  // 현재 카드의 상태와 사용자 응답에 따라 다음 간격 계산\n  if (card.status === 'new' || card.status === 'learning') {\n    if (response === 'again') {\n      newInterval = 1/1440; // 1분 (일 단위로 환산)\n      newEaseFactor = card.ease_factor;\n      newStatus = 'learning';\n    } else if (response === 'hard') {\n      newInterval = 10/1440; // 10분\n      newEaseFactor = card.ease_factor;\n      newStatus = 'learning';\n    } else if (response === 'good') {\n      newInterval = 1; // 1일\n      newEaseFactor = card.ease_factor;\n      newStatus = 'review';\n    } else if (response === 'easy') {\n      newInterval = 4; // 4일\n      newEaseFactor = card.ease_factor * 1.3;\n      newStatus = 'review';\n    }\n  } else if (card.status === 'review') {\n    if (response === 'again') {\n      newInterval = 1; // 1일\n      newEaseFactor = Math.max(1.3, card.ease_factor - 0.2);\n      newStatus = 'learning';\n    } else if (response === 'hard') {\n      newInterval = card.interval * 1.2;\n      newEaseFactor = Math.max(1.3, card.ease_factor - 0.15);\n      newStatus = 'review';\n    } else if (response === 'good') {\n      newInterval = card.interval * card.ease_factor;\n      newEaseFactor = card.ease_factor;\n      newStatus = 'review';\n    } else if (response === 'easy') {\n      newInterval = card.interval * card.ease_factor * 1.3;\n      newEaseFactor = card.ease_factor + 0.15;\n      newStatus = 'review';\n    }\n  }\n  \n  // 다음 복습 날짜 계산\n  const nextReviewDate = new Date(now);\n  nextReviewDate.setDate(now.getDate() + Math.round(newInterval));\n  \n  return {\n    interval: newInterval,\n    ease_factor: newEaseFactor,\n    status: newStatus,\n    next_review_date: nextReviewDate\n  };\n}\n```",
        "testStrategy": "1. 다양한 카드 상태와 사용자 응답 조합에 대해 간격 계산이 올바르게 작동하는지 테스트\n2. 카드 상태 전환이 올바르게 이루어지는지 확인 (New → Learning → Review)\n3. 오늘 학습해야 할 카드가 올바르게 선별되는지 테스트\n4. 카드 우선순위가 올바르게 적용되는지 확인\n5. 복습 일정이 올바르게 계산되는지 테스트\n6. 장기간 사용 시뮬레이션을 통해 알고리즘의 안정성 검증",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "SM-2 알고리즘 핵심 로직 구현",
            "description": "카드의 복습 간격을 동적으로 조정하는 SM-2 알고리즘의 수학적 로직을 구현합니다.",
            "dependencies": [],
            "details": "카드의 반복 횟수, 간격, 쉬움 요인(EF) 등을 기반으로 다음 복습 날짜와 간격을 계산하는 함수를 작성합니다. 품질 평가(0~5)에 따라 EF와 반복 횟수, 간격을 업데이트합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "카드 상태 관리 로직 구현",
            "description": "카드의 상태(New, Learning, Review)를 관리하고 상태 전환 로직을 구현합니다.",
            "dependencies": [
              "5.1"
            ],
            "details": "카드의 학습 상태에 따라 상태를 전환하는 함수와, 상태별로 다른 복습 로직을 적용하는 분기 처리를 구현합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "복습 간격 및 일정 계산 함수 구현",
            "description": "카드별 복습 간격과 다음 복습 일정을 계산하는 함수를 구현합니다.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "카드의 상태와 SM-2 로직에 따라 다음 복습 날짜를 계산하고, 데이터베이스에 저장할 수 있도록 합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "사용자 응답 처리 및 카드 상태/간격 반영",
            "description": "사용자의 응답(Again, Hard, Good, Easy 등)에 따라 카드의 상태와 복습 간격을 업데이트합니다.",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3"
            ],
            "details": "사용자 입력을 받아 품질 점수로 변환하고, 해당 점수에 따라 카드의 반복 횟수, EF, 간격, 상태를 업데이트합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "카드 큐 관리 및 오늘 학습 카드 선별",
            "description": "오늘 학습해야 할 카드 큐를 관리하고, 우선순위(New > Learning > Review)에 따라 큐를 구성합니다.",
            "dependencies": [
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "카드의 상태와 복습 일정에 따라 오늘 학습해야 할 카드를 선별하고, 우선순위에 따라 큐를 정렬합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "카드 진행 상태 및 학습 결과 업데이트",
            "description": "카드 학습 진행 상황을 실시간으로 업데이트하고, 학습 결과를 저장합니다.",
            "dependencies": [
              "5.4",
              "5.5"
            ],
            "details": "카드 학습 완료 시 진행 상태(복습 횟수, 마지막 학습일 등)를 업데이트하고, 데이터베이스에 반영합니다.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "장기 테스트 및 알고리즘 안정성 시뮬레이션",
            "description": "장기간 사용 시나리오를 시뮬레이션하여 SM-2 알고리즘의 안정성과 카드 상태 전환, 간격 계산의 정확성을 검증합니다.",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3",
              "5.4",
              "5.5",
              "5.6"
            ],
            "details": "다양한 카드 상태와 사용자 응답 조합, 장기 반복 학습 상황을 자동화 테스트로 시뮬레이션하여 알고리즘의 버그 및 논리 오류를 검증합니다.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "플래시카드 학습 화면 구현",
        "description": "사용자가 플래시카드를 학습할 수 있는 인터페이스를 구현합니다.",
        "details": "1. 플래시카드 표시 컴포넌트 구현:\n   - 카드 앞면/뒷면 전환 애니메이션\n   - 카드 내용 표시 (단어, 뜻, 예시문)\n2. 학습 컨트롤 버튼 구현:\n   - 카드 뒤집기 버튼\n   - 응답 버튼 (Again, Hard, Good, Easy)\n3. 학습 진행 상태 표시:\n   - 남은 카드 수 표시\n   - 현재 카드 진행 상태 표시\n4. 학습 방법 선택 옵션 구현:\n   - 양방향 학습 (기본)\n   - 단어 → 뜻 학습\n   - 뜻 → 단어 학습\n5. 학습 세션 관리 로직 구현:\n   - 학습 시작/종료 처리\n   - 카드 진행 상태 업데이트\n\n```typescript\n// 플래시카드 컴포넌트 예시\nconst FlashCard = ({ card, onResponse }) => {\n  const [showAnswer, setShowAnswer] = useState(false);\n  \n  const handleFlip = () => {\n    setShowAnswer(!showAnswer);\n  };\n  \n  const handleResponse = (response) => {\n    onResponse(card.id, response);\n    setShowAnswer(false);\n  };\n  \n  return (\n    <div className=\"flashcard-container\">\n      <div className={`flashcard ${showAnswer ? 'flipped' : ''}`} onClick={handleFlip}>\n        <div className=\"front\">\n          <h2>{card.front_content}</h2>\n        </div>\n        <div className=\"back\">\n          <h2>{card.back_content}</h2>\n          {card.example_memo && <p>{card.example_memo}</p>}\n        </div>\n      </div>\n      \n      {showAnswer && (\n        <div className=\"response-buttons\">\n          <button onClick={() => handleResponse('again')}>다시</button>\n          <button onClick={() => handleResponse('hard')}>어려움</button>\n          <button onClick={() => handleResponse('good')}>보통</button>\n          <button onClick={() => handleResponse('easy')}>쉬움</button>\n        </div>\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "1. 카드 뒤집기 기능이 정상적으로 작동하는지 테스트\n2. 응답 버튼이 올바르게 작동하고 카드 상태가 업데이트되는지 확인\n3. 다양한 학습 방법 옵션이 올바르게 적용되는지 테스트\n4. 학습 진행 상태가 정확하게 표시되는지 확인\n5. 여러 카드를 연속으로 학습할 때 정상적으로 작동하는지 테스트\n6. 모바일 환경에서도 UI가 올바르게 표시되는지 확인",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "TTS(Text-to-Speech) 기능 구현",
        "description": "Google Cloud 또는 Azure의 TTS API를 활용하여 플래시카드의 단어나 문장을 음성으로 들을 수 있는 기능을 구현합니다.",
        "details": "1. TTS API 연동 설정:\n   - Google Cloud Text-to-Speech API 또는 Azure Text-to-Speech API 계정 설정\n   - API 키 발급 및 환경 변수 설정\n2. TTS API 호출 서버 엔드포인트 구현:\n   - POST /api/tts - 텍스트를 음성으로 변환하는 API\n3. 언어 자동 감지 기능 구현 (선택적):\n   - 텍스트의 언어를 자동으로 감지하여 적절한 TTS 음성 선택\n4. TTS 재생 컨트롤 UI 구현:\n   - 재생 버튼\n   - 자동 재생 옵션\n5. 오디오 캐싱 기능 구현 (선택적):\n   - 자주 사용되는 오디오 파일 캐싱으로 API 호출 최소화\n\n```typescript\n// TTS API 엔드포인트 예시 (Google Cloud TTS 사용)\nimport { NextResponse } from 'next/server';\nimport { TextToSpeechClient } from '@google-cloud/text-to-speech';\n\nconst client = new TextToSpeechClient();\n\nexport async function POST(req: Request) {\n  try {\n    const { text, languageCode = 'ko-KR' } = await req.json();\n    \n    const request = {\n      input: { text },\n      voice: { languageCode, ssmlGender: 'NEUTRAL' },\n      audioConfig: { audioEncoding: 'MP3' },\n    };\n    \n    const [response] = await client.synthesizeSpeech(request);\n    const audioContent = response.audioContent;\n    \n    return new NextResponse(audioContent, {\n      headers: {\n        'Content-Type': 'audio/mpeg',\n      },\n    });\n  } catch (error) {\n    console.error('TTS error:', error);\n    return NextResponse.json({ error: 'Failed to generate speech' }, { status: 500 });\n  }\n}\n```",
        "testStrategy": "1. TTS API가 다양한 언어의 텍스트에 대해 올바르게 작동하는지 테스트\n2. 오디오 재생이 모든 주요 브라우저에서 정상적으로 작동하는지 확인\n3. 언어 자동 감지 기능이 정확하게 작동하는지 테스트\n4. 재생 버튼 및 자동 재생 옵션이 올바르게 작동하는지 확인\n5. API 호출 제한을 초과하지 않도록 캐싱 기능이 효과적으로 작동하는지 테스트\n6. 오류 상황(네트워크 오류, API 제한 등)에 대한 적절한 처리가 이루어지는지 확인",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "파일 내용 미리보기 및 편집 기능 구현",
        "description": "사용자가 파일 내의 플래시카드를 리스트 형태로 보고 편집할 수 있는 기능을 구현합니다.",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "details": "1. 플래시카드 CRUD API 엔드포인트 구현:\n   - POST /api/flashcards - 플래시카드 생성\n   - PUT /api/flashcards/[id] - 플래시카드 수정\n   - DELETE /api/flashcards/[id] - 플래시카드 삭제\n   - GET /api/flashcards?fileId=xxx - 파일별 플래시카드 목록\n\n2. FlashcardEditor 컴포넌트 구현:\n   - 플래시카드 추가/편집/삭제 UI\n   - PRD 요구사항에 맞는 3가지 필드: 공부할 단어(front), 뜻(back), 예시문/메모(notes)\n   - 언어 설정 기능 (TTS 준비)\n   - 카드 상태 표시 (새로운, 학습중, 복습, 중단)\n\n3. FileManager 통합:\n   - 파일 목록에서 \"플래시카드 편집\" 메뉴 추가\n   - BookOpen 아이콘으로 직관적 접근\n\n4. 데이터베이스 연동:\n   - Admin 클라이언트 사용으로 RLS 우회\n   - userId 기반 권한 검증\n   - 파일별 플래시카드 카운트 자동 업데이트\n\n```typescript\n// 플래시카드 생성 함수 예시\nasync function createFlashcard(fileId, cardData) {\n  try {\n    const response = await fetch('/api/flashcards', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        fileId,\n        ...cardData\n      }),\n    });\n    \n    if (!response.ok) {\n      throw new Error('Failed to create flashcard');\n    }\n    \n    const result = await response.json();\n    return result;\n  } catch (error) {\n    console.error('Error creating flashcard:', error);\n    throw error;\n  }\n}\n```",
        "testStrategy": "1. 플래시카드 목록이 올바르게 표시되는지 확인\n2. 플래시카드 추가, 수정, 삭제 기능이 정상적으로 작동하는지 테스트\n3. 언어 설정 기능이 올바르게 작동하는지 확인\n4. 카드 상태가 올바르게 표시되는지 테스트\n5. FileManager와의 통합이 정상적으로 작동하는지 확인\n6. 파일별 플래시카드 카운트가 자동으로 업데이트되는지 확인\n7. userId 기반 권한 검증이 올바르게 작동하는지 테스트\n8. Admin 클라이언트를 통한 RLS 우회가 정상적으로 작동하는지 확인",
        "subtasks": [
          {
            "id": 1,
            "title": "플래시카드 CRUD API 엔드포인트 구현",
            "description": "플래시카드 생성, 수정, 삭제, 조회를 위한 API 엔드포인트 구현",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "FlashcardEditor 컴포넌트 구현",
            "description": "플래시카드 추가/편집/삭제 UI 및 필드 구현",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "FileManager 통합",
            "description": "파일 목록에서 플래시카드 편집 메뉴 및 아이콘 추가",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "데이터베이스 연동",
            "description": "Admin 클라이언트 사용, 권한 검증, 카운트 자동 업데이트 구현",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "유연한 학습 스케줄링 기능 구현",
        "description": "사용자가 폴더 및 파일별로 학습 스케줄을 설정하고 관리할 수 있는 기능을 구현합니다.",
        "details": "1. 스케줄 설정 UI 구현:\n   - 폴더/파일별 요일 선택 인터페이스\n   - 스케줄 우선순위 관리 (파일 스케줄 > 폴더 스케줄)\n2. 스케줄 데이터 관리 로직 구현:\n   - 스케줄 생성, 수정, 삭제 기능\n   - 폴더/파일 스케줄 상속 및 우선순위 처리\n3. 오늘의 학습 목록 생성 로직 구현:\n   - 현재 요일에 맞는 폴더/파일 필터링\n   - Anki 로직에 따른 오늘 학습할 카드 선별\n4. 스케줄 관련 API 엔드포인트 구현:\n   - GET /api/schedules - 사용자의 모든 스케줄 조회\n   - POST /api/schedules - 새 스케줄 생성\n   - PUT /api/schedules/:id - 스케줄 정보 업데이트\n   - DELETE /api/schedules/:id - 스케줄 삭제\n   - GET /api/today - 오늘의 학습 목록 조회\n\n```typescript\n// 오늘의 학습 목록 조회 API 예시\nexport async function GET(req: Request) {\n  const supabase = createServerClient();\n  const { searchParams } = new URL(req.url);\n  const userId = searchParams.get('userId');\n  \n  if (!userId) {\n    return NextResponse.json({ error: 'User ID is required' }, { status: 400 });\n  }\n  \n  // 현재 요일 구하기 (0: 일요일, 1: 월요일, ...)\n  const today = new Date().getDay();\n  const dayOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][today];\n  \n  try {\n    // 1. 오늘 학습할 폴더 찾기\n    const { data: folderSchedules } = await supabase\n      .from('schedules')\n      .select('target_id')\n      .eq('user_id', userId)\n      .eq('target_type', 'folder')\n      .contains('days_of_week', [dayOfWeek]);\n    \n    const folderIds = folderSchedules.map(schedule => schedule.target_id);\n    \n    // 2. 오늘 학습할 파일 찾기 (직접 스케줄이 있는 파일 + 폴더 스케줄을 상속받는 파일)\n    // 2.1. 직접 스케줄이 있는 파일\n    const { data: fileSchedules } = await supabase\n      .from('schedules')\n      .select('target_id')\n      .eq('user_id', userId)\n      .eq('target_type', 'file')\n      .contains('days_of_week', [dayOfWeek]);\n    \n    const directFileIds = fileSchedules.map(schedule => schedule.target_id);\n    \n    // 2.2. 폴더 스케줄을 상속받는 파일\n    const { data: inheritedFiles } = await supabase\n      .from('files')\n      .select('id')\n      .eq('user_id', userId)\n      .in('folder_id', folderIds)\n      .not('id', 'in', directFileIds); // 직접 스케줄이 있는 파일 제외\n    \n    const inheritedFileIds = inheritedFiles.map(file => file.id);\n    \n    // 3. 모든 학습할 파일 ID 합치기\n    const allFileIds = [...directFileIds, ...inheritedFileIds];\n    \n    // 4. 파일 정보 가져오기\n    const { data: files } = await supabase\n      .from('files')\n      .select('*')\n      .in('id', allFileIds);\n    \n    // 5. 각 파일별 오늘 학습할 카드 수 계산\n    const todayStudyList = await Promise.all(files.map(async (file) => {\n      const { count: newCount } = await supabase\n        .from('card_progress')\n        .select('id', { count: 'exact' })\n        .eq('file_id', file.id)\n        .eq('status', 'new');\n      \n      const { count: learningCount } = await supabase\n        .from('card_progress')\n        .select('id', { count: 'exact' })\n        .eq('file_id', file.id)\n        .eq('status', 'learning')\n        .lte('next_review_date', new Date().toISOString());\n      \n      const { count: reviewCount } = await supabase\n        .from('card_progress')\n        .select('id', { count: 'exact' })\n        .eq('file_id', file.id)\n        .eq('status', 'review')\n        .lte('next_review_date', new Date().toISOString());\n      \n      return {\n        ...file,\n        cardCounts: {\n          new: newCount,\n          learning: learningCount,\n          review: reviewCount,\n          total: newCount + learningCount + reviewCount\n        }\n      };\n    }));\n    \n    return NextResponse.json(todayStudyList);\n  } catch (error) {\n    console.error('Error fetching today\\'s study list:', error);\n    return NextResponse.json({ error: 'Failed to fetch today\\'s study list' }, { status: 500 });\n  }\n}\n```",
        "testStrategy": "1. 폴더/파일별 스케줄 설정이 올바르게 작동하는지 테스트\n2. 스케줄 우선순위가 올바르게 적용되는지 확인 (파일 스케줄 > 폴더 스케줄)\n3. 오늘의 학습 목록이 현재 요일에 맞게 올바르게 생성되는지 테스트\n4. 요일이 변경될 때 학습 목록이 올바르게 업데이트되는지 확인\n5. 스케줄 변경 시 오늘의 학습 목록이 즉시 반영되는지 테스트\n6. 다양한 스케줄 조합에 대해 오늘의 학습 목록이 올바르게 생성되는지 확인",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "deferred",
        "subtasks": [
          {
            "id": 1,
            "title": "스케줄 설정 UI 설계 및 구현",
            "description": "사용자가 폴더 및 파일별로 요일, 반복 주기, 우선순위를 직관적으로 설정할 수 있는 UI를 설계하고 개발합니다.",
            "dependencies": [],
            "details": "폴더/파일별 스케줄 선택, 우선순위 시각화, 스케줄 편집 및 삭제 기능 포함",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "스케줄 데이터 관리 로직 개발",
            "description": "스케줄 생성, 수정, 삭제 및 폴더/파일별 상속 및 우선순위 처리 로직을 구현합니다.",
            "dependencies": [
              "9.1"
            ],
            "details": "스케줄 데이터 구조 설계, CRUD 함수, 우선순위 충돌 처리 로직 포함",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "우선순위 처리 및 상속 규칙 구현",
            "description": "파일 스케줄이 폴더 스케줄보다 우선 적용되도록 우선순위 및 상속 규칙을 명확히 구현합니다.",
            "dependencies": [
              "9.2"
            ],
            "details": "우선순위 비교 알고리즘, 상속 예외 처리, 테스트 케이스 작성",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "오늘의 학습 목록 생성 로직 개발",
            "description": "현재 요일과 스케줄에 따라 오늘 학습해야 할 폴더/파일/카드 목록을 동적으로 생성하는 로직을 구현합니다.",
            "dependencies": [
              "9.3"
            ],
            "details": "Anki 학습 로직 반영, 필터링 및 정렬, 실시간 목록 갱신 기능 포함",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "스케줄 및 학습 목록 관련 API 엔드포인트 구현",
            "description": "스케줄 및 오늘의 학습 목록을 위한 RESTful API 엔드포인트를 설계하고 구현합니다.",
            "dependencies": [
              "9.4"
            ],
            "details": "GET/POST/PUT/DELETE /api/schedules, GET /api/today 등 엔드포인트 구현 및 문서화",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "다양한 스케줄 조합 및 예외 상황 테스트",
            "description": "폴더/파일별 다양한 스케줄 조합, 우선순위 충돌, 요일 변경 등 모든 예외 상황에 대해 테스트를 수행합니다.",
            "dependencies": [
              "9.5"
            ],
            "details": "테스트 시나리오 작성, 자동화 테스트 코드 구현, 결과 검증 및 버그 수정",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "학습 진도 및 통계 기능 구현",
        "description": "사용자의 학습 진행 상황을 추적하고 표시하는 기능을 구현합니다.",
        "details": "1. 연속 학습일 수 관리 로직 구현:\n   - 매일 학습 완료 여부 추적\n   - 연속 학습일 수 계산 및 업데이트\n2. 오늘 할당량 완료 퍼센트 계산 로직 구현:\n   - 오늘 학습해야 할 총 카드 수 계산\n   - 완료한 카드 수 추적 및 퍼센트 계산\n3. 학습 통계 UI 구현:\n   - 연속 학습일 수 표시 (🔥 연속 학습 N일째)\n   - 오늘의 학습 완료율 프로그레스 바\n4. 학습 완료 처리 로직 구현:\n   - 오늘의 모든 카드를 학습 완료했을 때 처리\n   - 연속 학습일 수 업데이트\n5. 통계 관련 API 엔드포인트 구현:\n   - GET /api/stats/streak - 연속 학습일 수 조회\n   - GET /api/stats/today-progress - 오늘의 학습 진행률 조회\n   - POST /api/stats/complete-day - 오늘 학습 완료 처리\n\n```typescript\n// 연속 학습일 수 업데이트 함수 예시\nasync function updateLearningStreak(userId) {\n  const supabase = createServerClient();\n  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD 형식\n  \n  // 현재 사용자의 연속 학습 정보 가져오기\n  const { data: streakData } = await supabase\n    .from('learning_streaks')\n    .select('*')\n    .eq('user_id', userId)\n    .single();\n  \n  if (!streakData) {\n    // 처음 학습하는 경우 새 레코드 생성\n    await supabase\n      .from('learning_streaks')\n      .insert({\n        user_id: userId,\n        streak_count: 1,\n        last_study_date: today\n      });\n    return 1;\n  }\n  \n  const lastStudyDate = new Date(streakData.last_study_date);\n  const currentDate = new Date(today);\n  \n  // 날짜 차이 계산 (밀리초 → 일)\n  const diffTime = Math.abs(currentDate.getTime() - lastStudyDate.getTime());\n  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n  \n  let newStreakCount;\n  \n  if (diffDays === 0) {\n    // 오늘 이미 학습했음 (중복 호출)\n    newStreakCount = streakData.streak_count;\n  } else if (diffDays === 1) {\n    // 연속으로 학습함\n    newStreakCount = streakData.streak_count + 1;\n  } else {\n    // 하루 이상 건너뜀\n    newStreakCount = 1;\n  }\n  \n  // 연속 학습 정보 업데이트\n  await supabase\n    .from('learning_streaks')\n    .update({\n      streak_count: newStreakCount,\n      last_study_date: today\n    })\n    .eq('user_id', userId);\n  \n  return newStreakCount;\n}\n```",
        "testStrategy": "1. 연속 학습일 수가 올바르게 계산되고 표시되는지 테스트\n2. 하루를 건너뛰었을 때 연속 학습일 수가 초기화되는지 확인\n3. 오늘의 학습 완료율이 올바르게 계산되고 표시되는지 테스트\n4. 카드 학습 완료 시 진행률이 실시간으로 업데이트되는지 확인\n5. 날짜가 변경될 때 통계가 올바르게 초기화/업데이트되는지 테스트\n6. 여러 기기에서 접속했을 때 통계가 동기화되는지 확인",
        "priority": "medium",
        "dependencies": [
          5,
          9
        ],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "스페이스드 리피티션 알고리즘 리팩토링: Strategy/Factory 패턴 도입 및 CardServiceV2 제공",
        "description": "Task 5의 Anki 학습 로직을 Strategy/Factory 패턴으로 리팩토링하고, SM-2와 Leitner 구현체, 자동 마이그레이션, 신규 서비스 API(CardServiceV2), 테스트 및 사용 문서를 포함해 알고리즘을 유연하게 교체/확장 가능하도록 한다.",
        "details": "아키텍처 개요\n- 목적: 알고리즘 교체 가능성, 개방-폐쇄 원칙(OCP), 테스트 용이성 확보를 위해 Strategy + Factory 패턴 적용[2]. 컨텍스트는 서비스 계층(CardServiceV2)이 담당하며, 알고리즘 선택/주입은 Factory가 단일 책임으로 수행한다[1][2].\n- 핵심 컴포넌트\n  - 추상 전략: SpacedRepetitionStrategy (planNextReview, gradeResponse, migrateFrom 등)\n  - 구체 전략: AnkiSM2Strategy, LeitnerStrategy\n  - 생성기: AlgorithmFactory (싱글톤, 알고리즘 레지스트리/DI 훅 제공)\n  - 서비스: CardServiceV2 (전략 주입 받아 학습/스케줄/통계 연동 지점 제공)\n  - 마이그레이션: AlgorithmMigrationService (전략 간 데이터 변환 규칙 집합)\n\n도메인 및 데이터 모델 변경 제안\n- Card\n  - id, front, back, notes, language, state(new/learning/review/suspended)\n  - scheduling: { dueAt, interval, ease, reps, lapses, stepIndex?, bucket?, lastGrade }\n  - algorithm: { key: 'sm2'|'leitner'|'fsrs'|..., version }\n- UserPreference\n  - srAlgorithmKey, srParams (전략별 파라미터: 초기 ease, steps 등)\n- MigrationAudit\n  - fromKey, toKey, executedAt, counts, previewHash, dryRun\n\nStrategy 패턴 설계\n- interface SpacedRepetitionStrategy {\n    key: string;\n    version: string;\n    planNextReview(card, now): Schedule; // 초기/리뷰 스케줄 산출\n    gradeResponse(card, grade, now): { updatedCard, events };\n    supportsMigrationFrom(fromKey: string): boolean;\n    migrateFrom(card, fromKey): { updatedCard, notes };\n    validateParams(params): void;\n  }\n- AnkiSM2Strategy: SM-2 규칙(초기 ease, interval 증분, lapses 처리) 구현. 파라미터: easeFactorMin, easeDelta, steps.\n- LeitnerStrategy: 레이트너 상자 이동 규칙, 상자별 interval 매핑.\n\nFactory 패턴 설계\n- class AlgorithmFactory {\n    private static instance: AlgorithmFactory;\n    private registry = new Map<string, SpacedRepetitionStrategy>();\n    static getInstance(): AlgorithmFactory { /* 싱글톤 반환 */ }\n    register(strategy: SpacedRepetitionStrategy) { this.registry.set(strategy.key, strategy); }\n    get(key: string): SpacedRepetitionStrategy { /* 없으면 예외 */ }\n    list(): string[] { return [...this.registry.keys()]; }\n  }\n- 앱 부팅 시 register(new AnkiSM2Strategy()), register(new LeitnerStrategy()). 필요 시 DI 컨테이너와 통합.\n\nCardServiceV2 API 설계\n- 기능\n  - POST /api/v2/cards/grade: { cardId, grade, now?, algorithmKey? }\n  - GET /api/v2/algorithms: 사용 가능 알고리즘 목록\n  - POST /api/v2/algorithms/migrate: { fromKey, toKey, scope, dryRun }\n  - PUT /api/v2/user/preferences: { srAlgorithmKey, srParams }\n- 내부 동작\n  - algorithmKey 파라미터가 있으면 Factory로 전략 선택, 없으면 UserPreference의 srAlgorithmKey 사용.\n  - gradeResponse 결과를 영속화하고 통계/스케줄 파이프라인 훅 호출(Task 9/10 연계를 위한 이벤트).\n\n자동 마이그레이션 설계\n- Migration 모드: preview(dry-run), apply(batch), rollback(필요 시 snapshot 기반)\n- 변환 규칙 예:\n  - SM-2 → Leitner: reps/ease/interval 기반으로 bucket 추정, dueAt 재산정\n  - Leitner → SM-2: bucket을 reps/ease로 역매핑하여 초기 interval 재배치\n- 안전장치: 샘플 카드에 대한 시뮬레이션, outlier 검출(극단적 interval/dues), MigrationAudit 기록, 트랜잭션/배치 처리, 재시도 설계\n\n베스트 프랙티스 및 고려사항\n- OCP/SRP를 만족하는 전략 추가 절차 문서화[2].\n- 전략과 영속 모델의 결합 최소화: 변환용 어댑터 계층.\n- 시간 의존성 분리: Clock 인터페이스로 now 주입(테스트 안정화).\n- 결정적 테스트를 위한 순수 함수 경계 설계, side-effect는 리포지토리/이벤트 퍼블리셔로 분리.\n- 동시성: 동일 카드 동시 채점 시 낙관적 락(version)과 idempotency 키 사용.\n- 성능: 대량 마이그레이션은 스트리밍 배치(페이지네이션), 지표 로깅(소요시간/초당 처리량), 장애 시 재개 가능 체크포인트.\n- 관측가능성: 전략 키/버전, 입력/출력 핵심 필드 로깅(PII 제외), 샘플 레벨 트레이싱.\n\n코드 스니펫(의사코드)\n- Factory 사용\n  const factory = AlgorithmFactory.getInstance();\n  const strategy = factory.get(userPref.srAlgorithmKey);\n  const { updatedCard } = strategy.gradeResponse(card, grade, clock.now());\n  await repo.save(updatedCard);\n- 마이그레이션\n  for await (const card of repo.streamByAlgorithm(fromKey)) {\n    const target = factory.get(toKey);\n    if (!target.supportsMigrationFrom(fromKey)) continue;\n    const { updatedCard } = target.migrateFrom(card, fromKey);\n    batch.add(updatedCard);\n    if (batch.size === N) await repo.saveBatch(batch);\n  }\n\n문서화(사용 예시)\n- 사용자가 설정에서 알고리즘 변경 → 즉시/예약 마이그레이션 옵션, dry-run 리포트 확인.\n- 개발자 가이드: 새로운 알고리즘 추가 체크리스트(Strategy 구현, Factory 등록, 파라미터 검증, 마이그레이션 규칙, 테스트 케이스 추가).\n",
        "testStrategy": "단위 테스트\n- Strategy 공통 계약 테스트: 모든 구현체가 planNextReview/gradeResponse/migrateFrom/validateParams에 대해 동일한 시나리오 스위트를 통과.\n- AnkiSM2Strategy: ease/interval 업데이트 규칙, lapses 처리, steps 적용 경계값 테스트.\n- LeitnerStrategy: 정답/오답에 따른 bucket 이동, bucket→interval 매핑 검증.\n- AlgorithmFactory: 싱글톤 보장, register/get/list 정상 동작 및 미등록 키 예외.\n- Clock 주입으로 시간 의존 로직 결정적 테스트.\n\n통합 테스트\n- CardServiceV2: grade API가 사용자 기본 알고리즘을 사용하고 algorithmKey 오버라이드 시 교체되는지 검증. DB 영속성, 이벤트 발행 훅 확인.\n- 알고리즘 간 마이그레이션: dry-run에서 변환 통계가 일관적인지, apply 후 모든 카드의 algorithm.key가 변경되고 dueAt/interval이 합리적 범위인지.\n- 동시성: 동일 카드에 대해 동시 grade 요청 10개 발생 시 하나만 성공하고 나머지는 재시도/충돌 처리되는지.\n- 대량 배치: 100k 카드 마이그레이션을 페이지네이션/배치 저장으로 완료, 부분 실패시 재개 가능.\n\n계약/회귀 테스트\n- Strategy를 모킹해 UI/스케줄(Task 6/9/10)에 영향을 주는 계약을 스냅샷으로 고정. 새로운 알고리즘 추가 시 회귀 확인.\n\n문서 테스트\n- README/사용 가이드의 예제 코드가 빌드/실행 가능. 알고리즘 변경 플로우 스크린샷/시나리오 점검.\n",
        "status": "done",
        "dependencies": [
          5,
          6,
          9
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-08T06:36:58.857Z",
      "updated": "2025-08-11T04:14:58.561Z",
      "description": "Tasks for master context"
    }
  }
}