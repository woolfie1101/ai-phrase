# AI 기반 개인 맞춤형 간격 반복 학습 웹 애플리케이션 개발

## 1. 프로젝트 개요

이 프로젝트는 Anki의 핵심적인 간격 반복(Spaced Repetition) 학습 알고리즘을 기반으로 하면서도, 사용자 경험(UX)을 극대화하고 유연한 학습 스케줄링 및 직관적인 학습 진도 관리가 가능한 웹 기반 학습 애플리케이션을 개발하는 것을 목표로 합니다. 사용자는 자신의 학습 자료를 폴더와 파일 형태로 체계적으로 관리하고, 개인화된 학습 일정에 따라 효율적으로 복습하며, AI 기반 TTS를 통해 정확한 발음을 들으며 학습 효과를 높일 수 있습니다.

## 2. 핵심 기능 및 상세 설명

### 2.1. Anki 학습 로직 구현 (가장 중요)

Anki의 핵심은 간격 반복(Spaced Repetition) 알고리즘에 있습니다. 이는 사용자가 플래시카드를 얼마나 잘 기억하는지에 따라 다음 복습 시점을 동적으로 조정하여, 망각 곡선을 효율적으로 관리하고 정보를 장기 기억으로 전환하는 데 도움을 줍니다.

#### 구현해야 할 Anki 로직의 핵심 요소

**카드 상태 관리**: 각 플래시카드는 다음과 같은 상태를 가집니다.

- **새로운 카드 (New)**: 아직 학습되지 않은 카드. 처음에는 짧은 간격으로 여러 번 노출됩니다.
- **학습 중인 카드 (Learning)**: 최근에 학습을 시작하여 아직 완전히 숙달되지 않은 카드. 비교적 짧은 간격(예: 1분, 10분, 1일)으로 자주 복습됩니다.
- **복습 카드 (Review)**: 이미 학습되어 간격 반복 주기에 따라 복습이 필요한 카드. 점차 긴 간격(예: 3일, 7일, 15일, 1개월, 3개월...)으로 복습됩니다.

**복습 간격 알고리즘 (SM-2 또는 유사 알고리즘)**: 사용자가 플래시카드에 대한 정답을 평가(예: 다시, 어려움, 보통, 쉬움)하면, 시스템은 다음 복습 간격을 동적으로 계산하여 적용합니다.

- **"다시 (Again)"**: 가장 짧은 간격으로 즉시 또는 매우 짧은 시간 내에 다시 보여줍니다. 카드의 학습 진행 상태가 초기화될 수 있습니다.
- **"어려움 (Hard)"**: 현재 간격보다 짧지만 "다시"보다는 긴 간격으로 조정합니다. (예: 현재 간격의 50% 또는 고정된 짧은 간격)
- **"보통 (Good)"**: 다음 간격을 표준적으로 증가시킵니다. (예: 현재 간격 * 2.5배 또는 SM-2 알고리즘의 다음 단계)
- **"쉬움 (Easy)"**: 현재 간격보다 훨씬 긴 간격으로 조정합니다. (예: 현재 간격 * 3.5배 또는 SM-2 알고리즘의 다음 단계 + 추가 보너스)

**망각 곡선 반영**: 이 간격 조정은 인간의 망각 곡선(Ebbinghaus's Forgetting Curve)을 기반으로 합니다. 정보를 잊기 직전에 다시 노출시킴으로써 기억을 강화합니다.

**능동적 회상 (Active Recall)**: 사용자가 플래시카드의 앞면을 보고 답을 직접 떠올리려고 노력하는 과정으로, 이 과정 자체가 학습 효과를 높입니다.

**큐 (Queue) 관리**: 오늘 복습해야 할 카드(새로운 카드, 학습 중인 카드, 복습 카드)를 우선순위에 따라 사용자에게 보여주는 내부적인 큐 시스템이 필요합니다. 일반적으로 새로운 카드 → 학습 중인 카드 → 복습 카드 순으로 우선순위를 가집니다.

#### 개발 시 고려사항

- Anki의 SM-2 알고리즘 또는 이와 유사한 간격 반복 알고리즘의 원리를 충실히 구현해야 합니다.
- 사용자가 각 카드를 얼마나 잘 기억했는지 평가할 수 있는 명확한 UI (예: "다시", "어려움", "보통", "쉬움" 버튼)를 제공해야 합니다.
- 카드당 "남은 횟수" (오늘 학습해야 할 횟수)를 표시하여 사용자가 학습 진도를 인지할 수 있도록 합니다.

### 2.2. 폴더 및 파일 관리 시스템

#### 폴더 생성 및 관리

- 사용자는 학습 자료를 체계적으로 정리하기 위해 여러 폴더를 생성할 수 있어야 합니다.
- 폴더 이름 변경, 삭제 기능이 필요합니다.
- 폴더는 계층적으로 중첩될 수 있도록 구현합니다. (예: '영어' 폴더 안에 '단어', '문법' 폴더 등 무한 중첩 가능)

#### 파일 생성 및 관리 (학습 덱)

- 각 폴더 안에 여러 학습 파일(플래시카드 덱)을 생성할 수 있어야 합니다.
- 파일 이름 변경, 삭제 기능이 필요합니다.
- 파일은 최소 하나 이상의 플래시카드를 포함할 수 있습니다.

#### UI

직관적인 파일 탐색기 형태의 UI를 제공하여 폴더와 파일을 쉽게 생성, 이동, 삭제할 수 있도록 합니다. 드래그 앤 드롭으로 폴더/파일 이동 기능도 고려합니다.

### 2.3. 플래시카드 학습 화면

#### 플래시카드 구성 요소

각 플래시카드는 다음 3가지 요소를 가집니다:
- **공부할 단어 (필수)**
- **단어의 뜻 (필수)**
- **예시문/메모 (선택)**

#### 플래시카드 학습 방식

파일을 클릭하면 Anki와 동일한 방식으로 플래시카드가 표시됩니다.

**학습 방법 옵션**: 각 덱(파일)마다 다음 학습 방법 중 하나를 선택할 수 있는 옵션을 제공합니다.

1. **양방향 학습 (기본)**:
   - **단어 (앞면) → 단어의 뜻 및 예시문 (뒷면)**으로 학습 후, 다시 **단어의 뜻 및 예시문 (앞면) → 단어 (뒷면)**으로 학습하는 방식입니다.

2. **단어 → 뜻 학습**:
   - **단어 (앞면) → 단어의 뜻 및 예시문 (뒷면)**으로만 학습하는 방식입니다.

3. **뜻 → 단어 학습**:
   - **단어의 뜻 및 예시문 (앞면) → 단어 (뒷면)**으로만 학습하는 방식입니다.

사용자가 답을 생각한 뒤 "정답 보기" 또는 "카드 뒤집기" 버튼을 클릭하면 카드 뒷면(답변)이 표시됩니다.

카드 뒷면 표시 후, 사용자는 자신의 기억 정도에 따라 "다시", "어려움", "보통", "쉬움" 중 하나를 선택하여 다음 복습 간격을 결정합니다.

#### TTS (Text-to-Speech) 기능

- 플래시카드에 표시되는 **단어나 문장(앞면, 뒷면 모두)**을 TTS(Text-to-Speech)를 이용하여 발음으로 들을 수 있어야 합니다.
- AI 기반 TTS (예: Google Cloud Text-to-Speech, Azure Text-to-Speech 등) 사용을 필수적으로 권장합니다. 높은 품질의 자연스러운 발음을 제공해야 합니다.
- 카드 내용의 언어를 자동으로 감지하거나, 사용자가 카드별로 언어를 지정할 수 있도록 하여 해당 언어의 발음으로 재생되어야 합니다.
- TTS 음성 재생 버튼을 플래시카드 화면에 명확히 배치하며, 자동 재생 옵션도 고려합니다.

### 2.4. 파일 내용 미리보기 및 편집

#### 리스트 보기 기능

**리스트 보기 버튼**: 파일 리스트 옆에 "카드 목록 보기" 또는 "내용 편집"과 같은 버튼을 제공합니다.

**카드 목록 표시**: 이 버튼을 클릭하면 해당 파일 안에 있는 모든 플래시카드의 앞면과 뒷면 내용을 리스트 형태로 볼 수 있는 화면이 나타납니다. 각 카드는 고유 ID를 가집니다.

#### 카드 편집 기능

- 리스트 화면에서 개별 플래시카드를 추가, 수정, 삭제할 수 있어야 합니다.
- 각 카드는 공부할 단어, 단어의 뜻, 예시문/메모를 입력할 수 있는 필드로 구성됩니다. 예시문/메모는 선택 사항입니다.
- 필요하다면 이미지, 오디오 파일 등을 첨부할 수 있는 기능도 고려합니다.
- 카드 순서 변경 기능 (드래그 앤 드롭)도 있으면 좋습니다.

#### 학습 자료 대량 추가

- 사용자는 화면에서 값을 직접 입력하여 플래시카드를 추가할 수 있습니다.
- CSV 또는 Excel 파일 업로드를 통해 여러 플래시카드를 한 번에 대량으로 추가할 수 있는 기능을 제공합니다. 업로드 시 파일 포맷 가이드라인(예: 첫 번째 열은 단어, 두 번째 열은 뜻, 세 번째 열은 예시문 등)을 명확히 제시해야 합니다.

### 2.5. 유연한 학습 스케줄링 기능

#### 폴더/파일별 스케줄 설정

각 폴더 또는 파일에 대해 특정 요일(월, 화, 수, 목, 금, 토, 일)을 학습 스케줄로 지정할 수 있어야 합니다.

- **폴더 스케줄**: 폴더에 스케줄을 설정하면 해당 폴더 내의 모든 하위 파일에 기본적으로 이 스케줄이 적용됩니다.
- **파일 스케줄 (우선순위)**: 폴더 스케줄이 설정되어 있더라도, 폴더 내의 특정 파일은 폴더의 스케줄을 무시하고 자신만의 스케줄(예: B 폴더는 목, 금요일 학습이지만, B 폴더 안의 '특정 파일 X'는 화요일에만 학습)을 가질 수 있도록 합니다. 파일 스케줄이 폴더 스케줄보다 항상 우선합니다.

#### 메인 화면의 "오늘의 학습"

- 웹페이지의 메인 화면에 접속하면 현재 요일과 사용자의 스케줄 설정에 맞춰 학습해야 할 폴더와 파일 목록을 명확하게 표시합니다.
- 사용자가 해당 폴더나 파일을 클릭하면 바로 플래시카드 학습 화면으로 이동하여 학습을 시작할 수 있습니다.
- 오늘 학습해야 할 파일이 없으면 "오늘 학습할 내용이 없습니다."와 같은 메시지를 표시합니다.

### 2.6. 학습 진도 및 통계 표시

#### 연속 학습일 수

메인 화면에 "🔥 연속 학습 N일째"와 같이 사용자가 하루도 빠짐없이 학습을 완료한 연속 일수를 표시합니다.

**로직**:
- 오늘 학습해야 할 할당량 중 하나라도 완료하면 해당 일수를 +1 증가시킵니다. (예: 어제까지 301일째였다면, 오늘 학습 완료 시 302일째로 업데이트)
- 학습을 건너뛴 날이 있으면 연속 일수는 초기화됩니다.

#### 오늘 할당량 완료 퍼센트

- 메인 화면에 오늘 학습해야 할 총 카드 수(새로운 카드 + 학습 중인 카드 + 복습 카드) 대비 현재까지 완료한 카드 수의 퍼센테이지를 직관적인 UI(예: 프로그레스 바)로 표시합니다.
- (예: "오늘의 학습 완료율: 75%")
- 이 퍼센테이지는 폴더/파일별 스케줄과 Anki 로직에 따라 오늘 학습해야 할 모든 카드를 기준으로 계산됩니다.

## 3. 기술 스택

### 프레임워크
- **Next.js** (프론트엔드 및 백엔드 API 라우트/서버 컴포넌트 모두 활용)
- **Vercel 배포**: Next.js는 Vercel에 최적화되어 있어 빠른 배포와 뛰어난 성능을 제공합니다.

### UI/UX
- **UI 라이브러리**: Shadcn/ui (컴포넌트), Lucide-react (아이콘)
- **CSS 프레임워크**: Tailwind CSS (반응형 디자인 및 빠른 스타일링)

### 데이터베이스
- **Supabase** (PostgreSQL 기반)
- **MCP (Managed Cloud Platform) 지원**: Supabase의 강력한 기능을 활용하여 데이터베이스 관리 부담을 줄입니다.

### 인증/인가
- **Supabase Auth**를 사용하여 사용자 로그인, 회원가입 및 데이터 보안을 위한 강력한 인증 시스템을 Next.js API 라우트와 연동하여 구축합니다.
- **실시간 데이터 동기화**: Supabase Realtime 기능을 활용하여 학습 진행 상황 등 데이터 변경을 실시간으로 프론트엔드에 반영합니다.

### TTS API
- **Google Cloud Text-to-Speech API** 또는 **Azure Text-to-Speech API**
- API 키는 보안을 위해 Next.js의 서버 측 API 라우트에서 관리하고, 클라이언트 측에서는 해당 API 라우트를 통해 TTS 기능을 호출합니다.

## 4. 개발 진행 시 고려사항

### Next.js 통합 개발
- 프론트엔드 UI는 React 컴포넌트로 구현하며, 필요한 데이터 페칭 및 API 호출은 Next.js의 서버 컴포넌트(Server Components) 또는 API 라우트(API Routes)를 활용합니다.
- Anki 학습 로직의 복잡한 계산이나 민감한 데이터 처리는 Next.js API 라우트 내에서 처리하여 보안과 성능을 확보합니다.

### 반응형 디자인
모든 UI는 데스크톱, 태블릿, 모바일 등 다양한 기기 및 화면 크기에서 최적화된 사용자 경험을 제공해야 합니다. Tailwind CSS의 반응형 유틸리티를 적극 활용합니다.

### 성능 최적화
플래시카드 로딩 속도, TTS 재생 속도, UI 반응성 등 전반적인 애플리케이션의 성능을 최적화하여 부드러운 학습 경험을 제공합니다. Next.js의 이미지 최적화, 코드 스플리팅 기능 등을 적극 활용합니다.

### 데이터 동기화
Supabase Realtime 기능을 활용하여 사용자가 여러 기기에서 접근하더라도 학습 데이터(카드 진행 상황, 스케줄, 연속 학습일 등)가 실시간으로 올바르게 동기화되도록 구현합니다.

### 인증/인가
Supabase Auth를 사용하여 사용자 로그인, 회원가입 및 데이터 보안을 위한 강력한 인증 시스템을 구축합니다. 사용자별 데이터 접근 권한을 철저히 관리하며, Next.js 미들웨어(Middleware)를 활용하여 인증 상태에 따른 라우팅 제어를 구현합니다.

### 에러 핸들링
사용자에게 친화적인 에러 메시지를 제공하고, 예외 상황에 대한 적절한 처리를 구현합니다.

### 접근성
웹 표준을 준수하고, 키보드 내비게이션 등 접근성을 고려한 UI를 설계합니다.